// Generated by LiveScript 1.2.0
var ref$, values, pairsToObj, objToPairs, askServices, ref, signature_threshold;
ref$ = require('prelude-ls'), values = ref$.values, pairsToObj = ref$.pairsToObj, objToPairs = ref$.objToPairs;
askServices = angular.module('askServices', ['firebase']);
ref = new Firebase('https://askkkkk.firebaseio.com/');
signature_threshold = 500;
askServices.factory('authService', ['$firebase', '$q'].concat(function($firebase, $q){
  var service;
  return service = {
    isCandidate: function(id){
      var deferred;
      deferred = $q.defer();
      ref.child("users/" + id + "/candidate_id").once('value', function(snapshot){
        return deferred.resolve(snapshot.val());
      });
      return deferred.promise;
    },
    get: function(id){
      var deferred;
      deferred = $q.defer();
      ref.child("users/" + id).once('value', function(snapshot){
        return deferred.resolve(snapshot.val());
      });
      return deferred.promise;
    },
    onLogin: function(arg$){
      var uid, id, provider, displayName, ref$, first_name, last_name, username, verified, email, link, birthday, userRef;
      uid = arg$.uid, id = arg$.id, provider = arg$.provider, displayName = (ref$ = arg$.displayName) != null ? ref$ : '', first_name = (ref$ = arg$.first_name) != null ? ref$ : '', last_name = (ref$ = arg$.last_name) != null ? ref$ : '', username = (ref$ = arg$.username) != null ? ref$ : '', verified = (ref$ = arg$.verified) != null ? ref$ : '', email = (ref$ = arg$.email) != null ? ref$ : '', link = (ref$ = arg$.link) != null ? ref$ : '', birthday = (ref$ = arg$.birthday) != null ? ref$ : '';
      userRef = ref.child("users/" + id);
      userRef.update({
        uid: uid,
        id: id,
        provider: provider,
        user_id: id,
        displayName: displayName,
        first_name: first_name,
        last_name: last_name,
        username: username,
        verified: verified,
        email: email,
        link: link,
        birthday: birthday
      });
      return userRef.child('online').once('value', function(snapshot){
        if (snapshot.val()) {
          return;
        }
        userRef.child('online').set(true);
        return userRef.child('last_login_time').set(new Date().getTime());
      });
    },
    onLogout: function(arg$){
      var id, userRef;
      id = arg$.id;
      userRef = ref.child("users/" + id);
      return userRef.child('online').set(false);
    }
  };
}));
askServices.factory('candidateService', ['$firebase'].concat(function($firebase){
  var x$, service;
  x$ = service = $firebase(ref.child('candidates'));
  x$.get = function(id){
    return service.$child(id);
  };
  return x$;
}));
askServices.factory('userService', ['$firebase'].concat(function($firebase){
  var service;
  return service = {
    get: function(id){
      return $firebase(ref.child("users/" + id));
    }
  };
}));
askServices.factory('questionService', ['$firebase', '$q'].concat(function($firebase, $q){
  var x$, service;
  x$ = service = $firebase(ref.child('questions'));
  x$.$on('child_added', function(arg$){
    var snapshot, prevChild;
    snapshot = arg$.snapshot, prevChild = arg$.prevChild;
    service[snapshot.name].$addressing = service.$child(snapshot.name + "/addressing");
    service[snapshot.name].asker = $firebase(ref.child("users/" + snapshot.value.asker));
    return service[snapshot.name].postResponse = function(arg$){
      var postDate, responser, content;
      postDate = arg$.postDate, responser = arg$.responser, content = arg$.content;
      ref.child("questions/" + snapshot.name + "/addressing/" + responser + "/state").set('responded');
      ref.child("questions/" + snapshot.name + "/responses_count").transaction(function(currentValue){
        return currentValue + 1;
      });
      return service.$child("questions/" + snapshot.name + "/responses").$add({
        responser: responser,
        postDate: {
          year: postDate.getFullYear(),
          month: postDate.getMonth() + 1,
          day: postDate.getDate()
        },
        upVotesCount: 0,
        downVotesCount: 0,
        content: content.split(/\n\n/)
      });
    };
  });
  x$.$on('child_changed', function(arg$){
    var snapshot, prevChild;
    snapshot = arg$.snapshot, prevChild = arg$.prevChild;
    return service[snapshot.name].$addressing = service.$child(snapshot.name + "/addressing");
  });
  x$.get = function(questionId){
    var x$, questionRef;
    x$ = questionRef = service.$child(questionId);
    x$.$on('loaded', function(snap){
      questionRef.$id = questionId;
      questionRef.$addressing = questionRef.$child("addressing");
      questionRef.responses = questionRef.$child("responses");
      questionRef.asker = $firebase(ref.child("users/" + questionRef.asker));
      return questionRef.postResponse = function(arg$){
        var postDate, responser, content, deferred, rRef;
        postDate = arg$.postDate, responser = arg$.responser, content = arg$.content;
        ref.child("questions/" + questionId + "/addressing/" + responser + "/state").set('responded');
        ref.child("questions/" + questionId + "/responses_count").transaction(function(currentValue){
          return currentValue + 1;
        });
        deferred = $q.defer();
        rRef = ref.child("questions/" + questionId + "/responses").push();
        rRef.set({
          id: rRef.name(),
          responser: responser,
          postDate: {
            year: postDate.getFullYear(),
            month: postDate.getMonth() + 1,
            day: postDate.getDate()
          },
          upVotesCount: 0,
          downVotesCount: 0,
          content: content.split(/\n\n/)
        }, function(){
          return deferred.resolve();
        });
        return deferred.promise;
      };
    });
    return x$;
  };
  x$.post = function(arg$, onComplete){
    var title, content, category, addressing, post_date, deadline, asker;
    title = arg$.title, content = arg$.content, category = arg$.category, addressing = arg$.addressing, post_date = arg$.post_date, deadline = arg$.deadline, asker = arg$.asker;
    return ref.child('candidates').once('value', function(snapshot){
      var candidates;
      candidates = snapshot.val();
      addressing = pairsToObj(addressing.map(function(it){
        return [
          it, {
            state: 'pending'
          }
        ];
      }));
      content = content.split(/\n\n/);
      return service.$add({
        title: title,
        content: content,
        category: category,
        addressing: addressing,
        post_date: post_date,
        deadline: deadline,
        asker: asker,
        state: {
          collecting: 'collecting'
        },
        responses_count: 0,
        signatures_count: 0,
        votes_count: 0
      }).then(function(postRef){
        (function(meta){
          meta.$child("collecting/" + postRef.name()).$set(true);
        }.call(this, $firebase(ref.child('question_index'))));
        (function(meta){
          var i$, ref$, len$, c;
          for (i$ = 0, len$ = (ref$ = category).length; i$ < len$; ++i$) {
            c = ref$[i$];
            meta.$child(c + "/" + postRef.name()).$set(true);
          }
        }.call(this, $firebase(ref.child('category'))));
        (function(meta){
          var i$, ref$, len$, c;
          for (i$ = 0, len$ = (ref$ = keys(addressing)).length; i$ < len$; ++i$) {
            c = ref$[i$];
            meta.$child(c + "/questions/" + postRef.name()).$set(true);
          }
        }.call(this, $firebase(ref.child('candidate_meta'))));
        if (onComplete) {
          return onComplete(postRef);
        }
      });
    });
  };
  x$.upVoteResponse = function(arg$){
    var questionId, responseId, userId, rRef;
    questionId = arg$.questionId, responseId = arg$.responseId, userId = arg$.userId;
    rRef = ref.child("questions/" + questionId + "/responses/" + responseId);
    return rRef.child("votes/" + userId).once('value', function(snapshot){
      if (snapshot.val()) {
        return;
      }
      rRef.child("upVotes/" + userId).set(new Date().getTime());
      rRef.child("upVotesCount").transaction(function(it){
        return it + 1;
      });
      rRef.child("votes/" + userId).set(new Date().getTime());
      return rRef.child("votesCount").transaction(function(it){
        return it + 1;
      });
    });
  };
  x$.downVoteResponse = function(arg$){
    var questionId, responseId, userId, rRef;
    questionId = arg$.questionId, responseId = arg$.responseId, userId = arg$.userId;
    rRef = ref.child("questions/" + questionId + "/responses/" + responseId);
    return rRef.child("votes/" + userId).once('value', function(snapshot){
      if (snapshot.val()) {
        return;
      }
      rRef.child("downVotes/" + userId).set(new Date().getTime());
      rRef.child("downVotesCount").transaction(function(it){
        return it + 1;
      });
      rRef.child("votes/" + userId).set(new Date().getTime());
      return rRef.child("votesCount").transaction(function(it){
        return it + 1;
      });
    });
  };
  return x$;
}));
askServices.factory('signService', ['$firebase'].concat(function($firebase){
  var service;
  return service = {
    signature_threshold: signature_threshold,
    sign: function(userId, questionId){
      return ref.child("questions/" + questionId + "/signatures/" + userId).once('value', function(snapshot){
        var today, x$, y$;
        if (snapshot.val()) {
          return;
        }
        today = new Date();
        x$ = ref.child("questions/" + questionId + "/signatures/" + userId);
        x$.setWithPriority({
          date: {
            year: today.getFullYear(),
            month: today.getMonth() + 1,
            day: today.getDate()
          }
        }, today.getTime());
        y$ = ref.child("questions/" + questionId + "/signatures_count");
        y$.transaction(function(currentValue){
          return currentValue + 1;
        });
        y$.on('value', function(snapshot){
          console.log(snapshot.val());
          if (snapshot.val() >= signature_threshold) {
            return ref.child("questions/" + questionId + "/state/passed").set('passed');
          }
        });
        return y$;
      });
    }
  };
}));
/**
 * Filter an object to an array of its keys (properties) except those given be AngularFire.
 */
askServices.filter('toKeys', function(){
  return function(input, attributes){
    switch (false) {
    case !!angular.isObject(input):
      return input;
    default:
      return keys(input).filter(function(it){
        return it[0] !== '$';
      });
    }
  };
});
/**
 * Filter questions by candidate responses.
 */
askServices.filter('respondedByCandidate', function(){
  return function(input, candidateId){
    switch (false) {
    case !!candidateId:
      return null;
    case !angular.isArray(input):
      return input.filter(function(it){
        return it.addressing[candidateId];
      }).filter(function(it){
        return it.addressing[candidateId].state === 'responded';
      });
    case !!input.addressing:
      return null;
    case !!input.addressing[candidateId]:
      return null;
    default:
      return input.addressing[candidateId].state === 'responded';
    }
  };
});
/**
 * Filter questions by candidate responses.
 */
askServices.filter('pendedByCandidate', function(){
  return function(input, candidateId){
    switch (false) {
    case !!candidateId:
      return null;
    case !angular.isArray(input):
      return input.filter(function(it){
        return it.addressing[candidateId];
      }).filter(function(it){
        return it.addressing[candidateId].state === 'pending';
      });
    case !!input.addressing:
      return null;
    case !!input.addressing[candidateId]:
      return null;
    default:
      return input.addressing[candidateId].state === 'pending';
    }
  };
});
/**
 * Filter questions by signature threshold.
 */
askServices.filter('passedThreshold', function(){
  return function(input){
    switch (false) {
    case !!input:
      return null;
    case !angular.isArray(input):
      return input.filter(function(it){
        return it.state.passed;
      });
    case !input.state.passed:
      return input;
    default:
      return null;
    }
  };
});