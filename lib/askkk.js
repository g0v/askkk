// Generated by LiveScript 1.2.0
var keys, Firebase, AskKK;
keys = require('prelude-ls').keys;
Firebase = require('firebase');
AskKK = (function(){
  AskKK.displayName = 'AskKK';
  var prototype = AskKK.prototype, constructor = AskKK;
  function AskKK(baseUrl){
    this._firebase = null;
    if (!baseUrl) {
      throw new Error("Invalid base URL provided.");
    }
    this._firebase = new Firebase(baseUrl);
    this._userId = 1;
    this._candidateId = 1;
  }
  /**
   * Set candidate info.  If there is a candidate of the
   * same ID, her/his info will be erased.
   */
  prototype.setCandidate = function(id, arg$, onComplete){
    var name, email, candidateRef;
    name = arg$.name, email = arg$.email;
    candidateRef = this._firebase.child('/candidates').child(id);
    return candidateRef.set({
      id: id,
      name: name,
      email: email
    }, onComplete);
  };
  /**
   * Get candidate info from id.
   * Candidates ID are maintained by administrators.
   */
  prototype.getCandidate = function(id, onComplete){
    var candidateRef;
    candidateRef = this._firebase.child('/candidates').child(id);
    return candidateRef.on('value', function(snapshot){
      return onComplete(snapshot.val());
    });
  };
  /**
   * Update candidate info.  If there is a candidate of the
   * same ID, only the info specified in data will be updated.
   */
  prototype.updateCandidate = function(id, data, onComplete){
    var d, i$, ref$, len$, k, candidateRef;
    d = {
      id: id
    };
    for (i$ = 0, len$ = (ref$ = ['name', 'email']).length; i$ < len$; ++i$) {
      k = ref$[i$];
      if (data[k]) {
        d[k] = data[k];
      }
    }
    candidateRef = this._firebase.child('/candidates').child(id);
    return candidateRef.update(d, onComplete);
  };
  /**
   * Create a user.  User IDs are created by the `push`
   * method of Firebase.  onComplete is a callback whose
   * argument is an object containing user info, including ID.
   */
  prototype.createUser = function(arg$, onComplete){
    var name, email, usersRef, newRef;
    name = arg$.name, email = arg$.email;
    usersRef = this._firebase.child('/users');
    newRef = usersRef.push();
    return newRef.set({
      id: newRef.name(),
      name: name,
      email: email
    }, function(error){
      if (error) {
        return onComplete(error);
      } else {
        return newRef.on('value', function(snapshot){
          return onComplete(snapshot.val());
        });
      }
    });
  };
  /**
   * Get user info by ID.
   */
  prototype.getUser = function(id, onComplete){
    var userRef;
    userRef = this._firebase.child('/users').child(id);
    return userRef.on('value', function(snapshot){
      return onComplete(snapshot.val());
    });
  };
  /**
   * Update user info.
   * Only the info specified in the data will be updated.
   * If there are no user of the given ID, nothing happens,
   * and onComplete will be called with a null.
   */
  prototype.updateUser = function(id, data, onComplete){
    var d, i$, ref$, len$, k, userRef;
    d = {
      id: id
    };
    for (i$ = 0, len$ = (ref$ = ['name', 'email']).length; i$ < len$; ++i$) {
      k = ref$[i$];
      if (data[k]) {
        d[k] = data[k];
      }
    }
    userRef = this._firebase.child('/users').child(id);
    return userRef.on('value', function(snapshot){
      if (snapshot.val()) {
        return userRef.update(d, function(snapshot){
          return userRef.on('value', function(snapshot){
            return onComplete(snapshot.val());
          });
        });
      } else {
        return onComplete();
      }
    });
  };
  /**
   * Create a petition.
   */
  prototype.createPetition = function(arg$, onComplete){
    var title, candidates, story, petitionRef, userPetitionRef, candidateMetaRef, petitionIndexRef, data;
    title = arg$.title, candidates = arg$.candidates, story = arg$.story;
    if (!this._userId) {
      throw new Error("Need to be a user to create a petition.");
    }
    petitionRef = this._firebase.child('petitions').push();
    userPetitionRef = this._firebase.child('user_meta').child(this._userId).child('petitions');
    candidateMetaRef = this._firebase.child('candidate_meta');
    petitionIndexRef = this._firebase.child('petition_index');
    data = [
      {
        id: petitionRef.name(),
        author: this._userId
      }, title, candidates, story
    ];
    return petitionRef.set(data, function(error){
      var i$, ref$, len$, ca;
      if (error) {
        throw new Error("Error created a petition: " + error);
      }
      userPetitionRef.child(petitionRef.name()).set(true);
      for (i$ = 0, len$ = (ref$ = keys(candidates)).length; i$ < len$; ++i$) {
        ca = ref$[i$];
        candidateMetaRef.child(ca).child('petitions').child(petitionRef.name()).set(true);
      }
      petitionIndexRef.child('open').child(petitionRef.name()).set(true);
      return onComplete(data);
    });
  };
  /**
   * Sign an open petition to agree that it should be answered.
   */
  prototype.sign = function(){};
  /**
   * Respond to a petition.
   */
  prototype.respond = function(){};
  /**
   * Vote an answer as good/not good.
   */
  prototype.vote = function(){};
  return AskKK;
}());
module.exports.AskKK = AskKK;